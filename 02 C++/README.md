## C++

## 目录

1. 基础知识

2. 封装
3. 继承性
4. 多态
5. 模板
6. 异常
7. 高级C++

---

# 基础知识

## 成员函数

类和对象
类是创建对象的模板，不占用内存空间；对象是数据，需要内存来存储；

封装性：成员变量+成员函数

定义:

1. 定义在类内部，默认为内联函数；
2. 定义在类外部：使用范围解析运算符 :: 来定义

### ：和 :: 区别

单冒号 :

1. 结构体内位域的定义
2. 构造函数后起分割的作用，初始化列表
3. 类名冒号后面定义，继承；
4. switch:

双冒号 :: 作用域运算符

1. 命名空间
2. 全局作用域，当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分全局
3. 类作用域符号：C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写voidA::f()，表示这个f()函数是类A的成员函数。

### 成员函数 const 、constexpr用法

1. 末尾加const，表明该成员函数无法修改该类的成员变量， 实际上，就是对这个this指针加上了const修饰
2. 首部使用const 表示返回值为const；同时确认该成员函数可作用于const对象
3. 参数用为const，是被用来接受const和non-const[函数重载的原因]；
4. constexpr
   1. 作用： 引入更多的编译时计算能力
   2. 在 C 里面，const 很明确只有「只读」一个语义，不会混淆。C++ 在此基础上增加了「常量」语义，由 const 关键字来承担
   3. C++11 把「常量」语义拆出来，交给新引入的 constexpr 关键字
   4. 常量和只读的区别：
      1. 定义的变量在定义时初始化，不能在构造函数与其它属性与方法中初始化，也只能读取不能更改
      2. 只读： 定义的变量在运行期间也只能读取不能更改

### 类访问修饰public, private, protected

public:

1. 对象可以直接访问，可以不适用任何成员函数来设置和获取public变量的值，直接使用对象

protected：

1. 不能使用对象.来直接访问
2. 只有**类的成员函数**和**友元函数**可以访问proteced变量
3. protected变量在派生类中是可以访问的

private[默认属性]:

1. 不能使用对象.来直接访问
   1. 特别：
      1. 可以通过对象地址的便宜来访问私有地址
      2. http://c.biancheng.net/cpp/biancheng/view/3004.html
      3. 无法防止直接通过指针来访问。可认为是指针的强大，也可认为是 C++ 语言设计的瑕疵
2. 只能使用**类的成员函数**和**友元函数**可以访问private成员
   1. 默认情况，所有数据成员都是private, 在struct结构体中默认public继承
   2. 派生类中不可以访问

---

参考资料：
C++ 面向对象：类&对象， 继承，重载运算符和重载函数， 多态，数据抽象，数据封装，接口（抽象类）
http://c.biancheng.net/cplus/class/
https://www.runoob.com/cplusplus/cpp-classes-objects.html

类和对象
类是创建对象的模板，不占用内存空间；对象是数据，需要内存来存储；

封装性：成员变量+成员函数
